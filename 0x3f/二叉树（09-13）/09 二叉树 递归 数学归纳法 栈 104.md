

## 讲解 —— [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)





### 二叉树与递归

1. 如何思考二叉树相关问题？
    
2. 为什么需要使用递归？
    
3. 为什么这样写就一定能算出正确答案？
    
4. 计算机是怎么执行递归的？
    
5. 另一种递归思路


### 1. 如何思考二叉树相关问题？




给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

![[Pasted image 20250920213310.png]]

---


![[Pasted image 20250920213324.png]]


对于更一般的二叉树

不要一开始就陷入细节，==而是思考整棵树与其左右子树的关系==

整棵树的最大深度 = max (左子树的最大深度,右子树的最大深度) + 1


---

### 2. 为什么需要使用递归？


![[Pasted image 20250920213403.png]]


==原问题==: 计算整棵树的最大深度
==子问题==: 计算左/右子树的最大深度
子问题与原问题是相似的

类比循环，执行的代码也应该是相同的 但子问题需要把计算结果返给上一级问题 
这更适合用递归实现


---


![[Pasted image 20250920213452.png]]


由于子问题的规模比原问题小
不断递下去，总会有个尽头
即==递归的边界条件==（base case)
直接返回它的答案（归）

在这里，边界条件即为空节点




---




### 3. 为什么这样写就一定能算出正确答案？—— 数学归纳法



![[Pasted image 20250920213938.png]]





### 4. 计算机是怎么执行递归的？

“归”的时候，即 `return` 的时候，当前节点怎么知道 `return` 到哪个节点




### 5. 另一种递归思路 —— 自顶向下


往下传当前路径节点个数

![[Pasted image 20250920214834.png]]


```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function (root) {
    // 维护一个全局变量
    let ans = 0;
    function dfs(node, depth) {
        if (node === null) {
            return;
        }
        depth++;
        ans = Math.max(ans, depth);
        dfs(node.left, depth);
        dfs(node.right, depth);
    }
    dfs(root, 0);
    return ans;
};
```



### 代码实现 —— 自底向上


- 时间复杂度：O(n)，其中 n 为二叉树的节点个数。
- 空间复杂度：O(n)。最坏情况下，二叉树退化成一条链，递归需要 O(n) 的栈空间。


```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
	// 边界条件
    if(root === null){
        return 0;
    }
    const lDepth = maxDepth(root.left);
    const rDepth = maxDepth(root.right);
	
	// 整棵树的最大深度 = max (左子树的最大深度,右子树的最大深度) + 1
    return Math.max(lDepth, rDepth) + 1;
};
```



## 课后习题


### [111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)


#### 思路

最小深度是从根节点到最近==叶子节点==的最短路径上的节点数量。


思考整棵树与其左右子树的关系

- 如果一个节点是叶子节点（左右子树都为空），则深度为 1
- 否则，最小深度 = min (左子树最小深度，右子树最小深度) + 1
	- 特殊情况：如果左子树为空，则最小深度 = 右子树最小深度 + 1
	- 特殊情况：如果右子树为空，则最小深度 = 左子树最小深度 + 1

左子树为空 ——> ==没有叶子节点== ——> 无法计算最小深度

这里可以将深度视为 $\infty$

   ![[Pasted image 20250920221716.png]]



#### 代码 1 —— 自底向上

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function (root) {
    // 空树
    if (root === null) {
        return 0;
    }

    // 1. 左右子树都为空
    if (!root.left && !root.right) {
        return 1;
    }

    // 2. 左子树最小深度
    const lMinDepth = root.left ? minDepth(root.left) : Infinity;
    // 3. 右子树最小深度
    const rMinDepth = root.right ? minDepth(root.right) : Infinity;

    // 4. 最小深度 = min(左子树最小深度, 右子树最小深度) + 1
    return Math.min(lMinDepth, rMinDepth) + 1;



};
```




#### 代码 2 —— 自顶向下

1. 判断空树
2. 维护一个全局变量
3. `dfs(node, depth){}` 遍历节点
	1. 遍历到叶子节点，更新全局变量
	2. 先后遍历左子树，右子树
4. `dfs(root, 1)` 
5. 返回答案


```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function (root) {
    // 空树
    if (root === null) {
        return 0;
    }

    let ans = Infinity;

    function dfs(node, depth) {
        // 遍历到了叶子节点，更新最小深度，并 return
        if (!node.left && !node.right) {
            ans = Math.min(ans, depth);
            return;
        }

        // 遍历左子树
        if (node.left) {
            dfs(node.left, depth + 1);
        }
        // 遍历右子树
        if (node.right) {
            dfs(node.right, depth + 1);
        }
    }

    dfs(root, 1);

    return ans;

};
```






##### 剪枝

当前节点所在深度 >= 已知的最小深度 —— 直接 `return` 不用继续遍历了

- 为什么自底向上无法剪枝？
依赖子树结果，必须遍历所有节点


```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var minDepth = function (root) {
    // 空树
    if (root === null) {
        return 0;
    }

    let ans = Infinity;

    function dfs(node, depth) {
        // 剪枝
        if (depth >= ans) {
            return;
        }

        // 遍历到了叶子节点，更新最小深度，并 return
        if (!node.left && !node.right) {
            ans = Math.min(ans, depth);
            return;
        }

        // 遍历左子树
        if (node.left) {
            dfs(node.left, depth + 1);
        }
        // 遍历右子树
        if (node.right) {
            dfs(node.right, depth + 1);
        }
    }

    dfs(root, 1);

    return ans;

};
```





### [404. 左叶子之和](https://leetcode.cn/problems/sum-of-left-leaves/)

节点数在 [1, 1000] 范围内 —— 不用判断空树


#### 版本 1

思考整棵树与其左右子树的关系

1. 左右子树都为空：0

```
输入: root = [1]
输出: 0
```

2. 整棵树的左叶子之和 = 左子树的左叶子之和 + 右子树的左叶子之和



```js
var sumOfLeftLeaves = function (root) {
    if (!root.left && !root.right) {
        return 0;
    }

    const lSum = sumOfLeftLeaves(root.left);
    const rSum = sumOfLeftLeaves(root.right);

    return lSum + rSum;
};
```


---

#### 版本 2


- 为什么最大深度的逻辑能直接生效？

最大深度的核心是 “当前节点的深度 = 子树的最大深度 + 1”

子树的 “最大深度” 就是父节点计算时需要的 “直接素材”—— 不管子树是叶子还是非叶子，只要拿到子树的最大深度，加 1 就是当前节点的深度。

比如叶子节点（左右子树都空）：左、右子树深度都是 0，所以叶子节点深度 = max (0,0)+1 = 1，完全符合定义



- 左叶子之和的逻辑缺了什么？

当前逻辑认为 “整棵树的左叶子之和 = 左子树的左叶子之和 + 右子树的左叶子之和”
但这个等式只对 “非叶子节点的子树” 成立，漏掉了 “<u>当前节点的左孩子本身就是左叶子</u>” 的情况。

```plaintext
    3
   / 
  9  （9 是叶子节点）
  
```



递归问题的 “父子关系” 很容易漏掉 “当前节点的直接贡献

汇总 + 贡献 —— 子节点结果的汇总 + 当前节点自己的直接贡献
核心就是 “给当前节点‘安排活’”，别让它只做 “子节点结果的传话筒”
<u>问自己：当前节点能 “直接判断” 出什么结果？</u>




```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var sumOfLeftLeaves = function (root) {
    // 空节点没有左叶子
    if (root === null) {
        return 0;
    }

    // 左子树与右子树的左叶子之和
    const lSum = sumOfLeftLeaves(root.left);
    const rSum = sumOfLeftLeaves(root.right);
    let sum = lSum + rSum;

    // 特殊情况：左子树为叶子
    const left = root.left;
    if (left && !left.left && !left.right) {
        sum += left.val;
    }

    return sum;
};
```








### [112. 路径总和](https://leetcode.cn/problems/path-sum/)


```js
var hasPathSum = function(root, targetSum) {
    if (root === null){
        return false;
    }

    function dfs(node, val){
    // 1. 当前节点为叶子时判断
        if (!node){
            if (val === targetSum){
                return true;
            }

            return;
        }

        dfs(node.left, val + node.left.val);
        dfs(node.right, val + node.right.val);
    }

    dfs(root, root.val);
};
```






