

## 例题


### [98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)


**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **严格小于** 当前节点的数。
- 节点的右子树只包含 **严格大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。




#### 前序遍历：先判断，再递归


![[Pasted image 20250923102051.png]]



根节点的左子树所有节点值都必须 <5
即，这些节点的值都必须落在 \($-\infty$, 5)

对于节点值为2的节点的右子树所有所有节点都必须 >2
则更新区间左边 \(2, 5)

递归（前序遍历：先访问节点值，再递归左右子树）
- 传入节点 + 开区间的范围
- 先判断节点的值是否在开区间范围内，再往下递归
- 往左递归，则更新右边界为节点值
- 往右递归，则更新左边界为节点值
- 特别注意：根节点无父节点，则初始化为($-\infty$, $+\infty$)



复杂度分析

- 时间复杂度：O(n)，其中 n 为二叉搜索树的节点个数。
- 空间复杂度：O(n)。最坏情况下，二叉搜索树退化成一条链（注意题目没有保证它是平衡树），因此递归需要 O(n) 的栈空间。





```js
var isValidBST = function (root) {
    // 传入节点的同时，传入区间
    const preorder = (node, left, right) => {
        // 边界条件：空节点
        if (!node) {
            return true;
        }

        // 判断当前节点是否在区间内
        if (node.val <= left || node.val >= right) {
            return false;
        }

        // 递归左右子树

        // 递归左子树：更新上限
        const isLeftValid = preorder(node.left, left, node.val);
        // 递归右子树：更新下限
        const isRightValid = preorder(node.right, node.val, right);

        // 返回当前节点结果
        return isLeftValid && isRightValid;

    }

    return preorder(root, -Infinity, Infinity);
};
```





#### 中序遍历：大于上一个节点



![[Pasted image 20250923104437.png]]


二叉搜索树的一个关键性质是：对它进行**中序遍历**（左-根-右）时，所有节点的值会**严格递增**


- 为什么在 **中序遍历** 的代码中，没有像 **前序遍历** 那样用 `const isLeftValid = ...` 这样的变量来接收递归结果
	- 在前序遍历中，我们是**自上而下**地传递有效性信息。每个父节点都**依赖**其左右子树的验证结果来做出最终判断。
	- 中序遍历的逻辑是**自下而上**地验证一个**递增序列**。它的核心是“短路”。

```js
var isValidBST = function (root) {
    // 根节点没有上一个节点，设置为无穷小
    let pre = -Infinity;

    // 中序遍历
    const inorder = (node) => {
        // 边界条件：空节点
        if (!node) {
            return true;
        }

        // 左 根 右
        // 左子树和当前节点不满足，直接短路

        // 递归左子树
        if (!inorder(node.left)) {
            return false;
        }

        // 检查当前节点
        if (node.val <= pre) {
            return false;
        }
        // 更新前一个节点值
        pre = node.val;

        // 递归右子树
        return inorder(node.right);
    }

    return inorder(root);
};
```




#### 后序遍历：先递归，再判断


![[Pasted image 20250923111939.png]]





后序遍历（左-右-根）的特点是**自底向上**地处理节点
这意味着，要判断一个节点是否有效，我们必须先知道其左右子树是否都是有效的 `BST`

后序遍历的思路需要**左右子树**向父节点**返回**一些信息，通常是：

1. 该子树是否为有效的 `BST`
2. 如果有效，该子树中的**最大值**和**最小值**
    
父节点拿到这些信息后，才能进行最终的判断：

1. 左子树的最大值**严格小于**当前节点的值
2. 右子树的最小值**严格大于**当前节点的值。
3. 左右子树本身都是有效的 `BST`



## 问题


### 信息的传递方向


#### 前序遍历（从上往下传递信息）

* **思考模式：** “我（根节点）要先判断自己是否满足要求，然后告诉我的孩子们，你们要满足什么范围。”
* **信息流：** 父节点将**有效值的范围**（信息）作为参数**向下**传递给子节点。
* **逻辑实现：**
    * 在递归调用之前，检查当前节点是否满足范围要求。
    * 如果满足，就递归地向左右子树传递**更新后的范围**。
* **优势：** 逻辑直观，与 BST 定义高度吻合，可以**立即返回**（短路），效率高。

---

#### **后序遍历（从下往上传递信息）**

* **思考模式：** “我的孩子们，你们先去告诉我，你们是不是合法的 BST，以及你们的最大值和最小值。等我拿到这些信息，我再来判断我是否满足要求。”
* **信息流：** 子节点在递归返回时，将**验证结果**和**边界值**（信息）**向上**返回给父节点。
* **逻辑实现：**
    * 先递归调用左右子树，获取它们的结果。
    * 得到结果后，再在当前节点进行判断。
* **优势：** 逻辑上更符合自底向上解决问题的模式。
* **劣势：** 无法“短路”，必须等待所有子树遍历完成才能做最终判断，因此效率相对较低。

---

#### **中序遍历的独特之处**

你也可以把中序遍历加入这个对比，它的信息流也很特别。

* **思考模式：** “我们不传递范围，也不传递结果。我们只按照顺序一个个地检查。我只需要和我的**前一个兄弟**比大小。”
* **信息流：** 通过一个**外部变量**，在整个遍历过程中共享和更新**“上一个节点的值”**。
* **逻辑实现：**
    * 遍历顺序是**左 -> 根 -> 右**。
    * 在访问根节点时，与上一个节点（`pre`）进行比较。
* **优势：** 代码最简洁，思路最优雅，同时也能有效“短路”，效率也很高。

将这三种遍历方式放在一起思考，你会对二叉树的递归思想有更深刻的理解。每种遍历方式都代表着一种不同的**解决问题模式**。













## 课后作业



700. 二叉搜索树中的搜索 https://leetcode.cn/problems/search-in-a-binary-search-tree/
701. 二叉搜索树的范围和 https://leetcode.cn/problems/range-sum-of-bst/
702. 二叉搜索树的最小绝对差 https://leetcode.cn/problems/minimum-absolute-difference-in-bst/
703. 二叉搜索树最近节点查询 https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/
704. 二叉搜索树中的众数 https://leetcode.cn/problems/find-mode-in-binary-search-tree/
705. 二叉搜索树中第 K 小的元素 https://leetcode.cn/problems/kth-smallest-element-in-a-bst/
706. 二叉搜索子树的最大键值和 https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/
707. 从前序与中序遍历序列构造二叉树 https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
708. 从中序与后序遍历序列构造二叉树 https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/
709. 根据前序和后序遍历构造二叉树 https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/
710. 删点成林 https://leetcode.cn/problems/delete-nodes-and-return-forest/