

## 例题



### [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)


- **祖先**（不是本身）：左子树有p或q，右子树有p或q
	- 依赖左右子树 ——> 自底向上递归（左右子树传递信息给当前节点）
		- 左右子树都没找到：`return null`
		- 左子树 / 右子树找到：`return left / right`

- **最近**：
	- “最近公共祖先” 的本质是 “最深的公共祖先”
	- “自底向上” 就可以锁定 “最深”
		- 找到 p或q，则一路向上返回 p或q
		- 找打非自身公共祖先 x，也是一路向上返回




- **时间复杂度**：O (n)，其中 n 是二叉树的节点数，因为每个节点最多被访问一次。
- **空间复杂度**：O (h)，其中 h 是二叉树的高度，递归调用栈的深度取决于树的高度（最坏情况下为 O (n)，即斜树）。





![[Pasted image 20250924222543.png]]











```js
var lowestCommonAncestor = function(root, p, q) {
    // 边界条件：为空 或者 自身为p q
    if(!root || root === p || root === q){
        return root;
    }

    // 拿到左右子树信息
    // 递归左右子树
    const left = lowestCommonAncestor(root.left, p, q);
    const right = lowestCommonAncestor(root.right, p, q);

    // 左右子树都找到，当前节点为 LCA
    if(left && right){
        return root;
    }

    // 左右子树只找到一个
    if(left){
        return left;
    }

    return right;
};
```




### [235. 二叉搜索树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)


- **利用二叉搜索树（`BST`）的有序特性**
	- x 落在 \[p,q] 
- **自顶向下**直接定位，有序特性可以剪枝


```js
var lowestCommonAncestor = function (root, p, q) {
    const val = root.val;

    // 太小往右走
    if (val < p.val && val < q.val) return lowestCommonAncestor(root.right, p, q);
    // 太大往左走
    else if (val > p.val && val > q.val) return lowestCommonAncestor(root.left, p, q);
    // 找到
    else return root;
};
```




## 课后






课后作业： 1123. 最深叶节点的最近公共祖先 https://leetcode.cn/problems/lowest-common-ancestor-of-deepest-leaves/