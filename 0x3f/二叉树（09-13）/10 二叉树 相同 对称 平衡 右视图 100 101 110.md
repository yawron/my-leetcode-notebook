
## 例题


### [100. 相同的树](https://leetcode.cn/problems/same-tree/)

核心思路：递归（判断两棵树是否相同，我们可以将问题分解为更小的子问题）
1. **比较根节点：** 首先，判断两棵树的根节点 `p` 和 `q` 是否都存在，以及它们的值是否相等。
2. **比较左子树：** 如果根节点相同，那么递归地判断它们的左子树 `p.left` 和 `q.left` 是否相同。
3. **比较右子树：** 同时，递归地判断它们的右子树 `p.right` 和 `q.right` 是否相同。


边界条件：
- **`p` 和 `q` 都为空：** 如果两棵树都走到了尽头（即都是 `null`），说明它们在这一路径上是相同的，返回 `true`。
- **其中一个为空，另一个不为空：** 如果一棵树的某个节点是 `null`，而另一棵树的对应位置有节点，那么它们的结构不一致，返回 `false`。
- **节点值不相等：** 如果 `p` 和 `q` 都不为空，但它们的值 `p.val` 和 `q.val` 不相等，返回 `false`。

复杂度分析：
- 时间复杂度：`O(min(n,m))`，其中 n 为 p 的节点个数，m 为 q 的节点个数。
- 空间复杂度：`O(min(n,m))`。最坏情况下，二叉树退化成一条链，递归需要 `O(min(n,m))` 的栈空间。



```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function(p, q) {
    // 边界条件：有一个是空节点
    if(!p || !q){
        // 两个都为空返回 true，否则返回 false
        return p === q;
    }

    // 两个节点都存在，判断值是否相同
    if(p.val !== q.val){
        return false;
    }

    // 递归判断左右子树值是否相同
    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);

};
```









### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)





```js
var isSymmetric = function (root) {
    // const left = root.left;
    // const right = root.right;

    // if (!left || !right) {
    //     return left === right;
    // }

    // leetcode 100
    const isSameTree = function (p, q) {
        if (!p || !q) {
            return p === q;
        }
        if (p.val !== q.val) {
            return false;
        }
        // left-right && right-left
        return isSameTree(p.left, q.right) && isSameTree(p.right, q.left);
    };

    return isSameTree(root.left, root.right);
};


```





### [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)



**平衡二叉树** 是指该树所有节点的左右子树的高度相差不超过 1



如果你从上往下（根节点到叶子节点）去思考，你会发现，为了判断一个节点是否平衡，你需要先知道它的左右子树的高度。而计算子树的高度本身就是一个递归过程。这样就会导致大量的重复计算，效率很低。


这种方法的缺点是效率低下。`getHeight` 函数在每个节点都会被调用，导致大量重复计算，时间复杂度高达 O(n²)。

```js
// 伪代码
const isBalanced = (root) => {
    if (!root) return true;
    
    // 计算左右子树的高度
    const leftHeight = getHeight(root.left);
    const rightHeight = getHeight(root.right);
    
    // 检查当前节点的高度差
    if (Math.abs(leftHeight - rightHeight) > 1) {
        return false;
    }
    
    // 递归检查左右子树
    return isBalanced(root.left) && isBalanced(root.right);
};
// 这里的 getHeight 函数需要单独写，它会遍历整个子树
```




#### 自底向上


##### 思路

**自底向上**的递归优化，将**属性判断（平衡）和数值计算（高度）结合起来，用一个特殊的返回值来剪枝**，从而将时间复杂度从 O(n²) 优化到 O(n)。


**更优的思路是：** **自底向上（从叶子节点到根节点）**进行递归。在回溯的过程中，我们同时完成两件事：

1. **计算高度：** 返回当前子树的真实高度。
    
2. **判断平衡：** 如果发现任何一个子树不平衡，就立即返回一个特殊值（比如 `-1`），以此来告诉上层调用者：“这棵树已经不平衡了，可以提前结束了。”



**递归过程：**

1. 首先递归调用左右子树，获取它们的平衡状态和高度。 
2. 如果左子树或右子树已经**不平衡（返回 -1）**，那么整个树肯定也不平衡，直接返回 -1。
3. 如果左右子树都平衡，计算当前节点的高度：`height = Math.max(leftHeight, rightHeight) + 1`。
4. 同时，检查当前节点的左右子树高度差是否超过 1。如果超过，返回 -1；否则，返回计算出的高度。

##### 代码


```js
var isBalanced = function(root) {
    // 左右子树不平衡，整个树就不平衡
    // 高度差判断当前节点是否平衡
    // 独立的高度计算函数
    return getHeight(root) === -1 ? false : true;
};

const getHeight = (node) => {
    // 当前节点高度为左右子树高度的更大值 +1

    // if(node.left){
    //     getHeight(node.left);
    // }
    // if(node.right){
    //     getHeight(node.right);
    // }

    if(!node){
        return 0;
    }

    // 拿到左右子树高度
    const leftHeight = getHeight(node.left);
    const rightHeight = getHeight(node.right);

    // 判断左右子树是否平衡
    if(leftHeight === -1 || rightHeight === -1){
        return -1;
    }

    // 左右子树此时都平衡，计算当前节点高度，判断当前节点是否平衡
    return Math.abs(leftHeight - rightHeight) > 1 ? -1 : Math.max(leftHeight, rightHeight) + 1;
}
```





### [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)


#### `BFS`




`BFS` 是一种层序遍历，它使用队列来逐层访问节点。右视图的节点就是每一层的**最后一个节点**。


- **时间复杂度：** **O(n)**
    - n 是二叉树中节点的数量。每个节点只会被访问一次，并被加入队列一次。
- **空间复杂度：** **O(m)**
    - m 是二叉树中**最宽**的那一层的节点数量。在最坏的情况下（比如一个满二叉树），最后一层的节点数量接近 n/2，所以空间复杂度是 O(n)。


```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 * this.val = (val===undefined ? 0 : val)
 * this.left = (left===undefined ? null : left)
 * this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function(root) {
	// 空树判断
    if (!root) {
        return [];
    }

    const result = [];
    const queue = [root];

    while (queue.length > 0) {
        const levelSize = queue.length;
        // 遍历当前层的所有节点
        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift();
            // 如果是当前层的最后一个节点，将其值加入结果
            if (i === levelSize - 1) {
                result.push(node.val);
            }

            // 将下一层的节点加入队列
            if (node.left) {
                queue.push(node.left);
            }
            if (node.right) {
                queue.push(node.right);
            }
        }
    }

    return result;
};
```



#### `DFS` —— 递归




通过**优先遍历右子树**来确保先访问到每层最右边的节点


- **时间复杂度：** **O(n)**  
    - n 是二叉树中节点的数量。每个节点也只会被访问一次。
- **空间复杂度：** **O(h)**
    - h 是二叉树的**高度**。空间复杂度主要取决于递归调用栈的深度。在最坏的情况下（比如一个单向链表），h 等于 n，所以空间复杂度是 O(n)。在最好的情况下（平衡二叉树），h 等于 log(n)，所以空间复杂度是 O(log n)。


```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 * this.val = (val===undefined ? 0 : val)
 * this.left = (left===undefined ? null : left)
 * this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function(root) {
    const result = [];

    const dfs = (node, depth) => {
        if (!node) {
            return;
        }

        // 如果结果数组的长度等于当前深度，说明这是第一次访问该层
        // 那么这个节点就是该层最右边的节点
        if (depth === result.length) {
            result.push(node.val);
        }

        // 优先递归右子树，再递归左子树
        dfs(node.right, depth + 1);
        dfs(node.left, depth + 1);
    };

    dfs(root, 0);
    return result;
};
```



## 思考



### `DFS` 辅助函数



是否需要在递归过程中传递额外的信息



- 需要辅助函数的情况：

当你在递归时，除了当前节点本身，还需要传递其他状态信息时，通常会使用辅助函数。这些信息可以是：

- 当前深度或层级 (如 `LeetCode 199：二叉树的右视图`)
- 最大值或最小值
- 父节点或兄弟节点
- 累积的结果（比如一个数组）


- 不需要辅助函数的情况：

当递归函数只依赖于当前节点，并且它的返回值（比如 `true` 或 `false`）就足以决定整个问题的结果时，通常不需要额外的辅助函数。这类递归被称为“自顶向下”或“自底向上”的纯递归。

示例： `LeetCode 100 - 相同的树`



### 思考模式 - 110

你在写 `getHeight` 函数时，之所以会习惯性地先判断 `node.left` 和 `node.right` 是否存在，是因为你正在使用一种<u>自顶向下</u>的思考模式。

这是一种非常自然的思维方式，你在“向下”遍历树时，总会先问自己：“这个节点有左子树吗？有右子树吗？” 这种思考方式在许多树遍历问题（比如前序、中序、后序遍历）中是正确的。

在这种**自底向上**的思维中，你根本不需要在递归调用前判断 `node.left` 或 `node.right` 是否存在。因为你的递归**终止条件**（即 `if (!node) { return 0; }`）会处理所有空节点的情况。


```js

var isBalanced = function(root) {
    // 左右子树不平衡，整个树就不平衡
    // 高度差判断当前节点是否平衡
    // 独立的高度计算函数
};

const getHeight = (node) => {
    // 当前节点高度为左右子树高度的更大值 +1
    if(node.left){
        getHeight(node.left);
    }
    if(node.right){
        getHeight(node.right);
    }

    return 
}
```














## 课后作业



### [965. 单值二叉树](https://leetcode.cn/problems/univalued-binary-tree/)


- **如何“直接结束递归”**：
	- 这是最关键的问题。你不能在递归函数内部直接中断整个主函数的执行。
	- 正确的做法是，让 `dfs` 函数返回一个布尔值，并在每次递归调用后**检查其返回值**。如果子调用的结果是 `false`，就立即返回 `false`。
	- 同 `110. 平衡二叉树`


自解代码
```js
var isUnivalTree = function (root) {
    val = root.val;

    const dfs = (node) => {
        if (!node) {
            return;
        }

        // 怎么直接结束递归？
        if (node.val !== val) {
            return false;
        }

        dfs(node.left);
        dfs(node.right);
    }

    return true;
};
```




这就是“层层传递”的精髓。每一个 `dfs` 调用都会把它的检查结果返回给它的上级。只要有一个环节发现问题（返回 `false`），这个 `false` 就会像一个链条一样，一层层地传递到最顶层，从而让整个过程提前结束。

```js
var isUnivalTree = function (root) {
    val = root.val;

    // dfs 返回一个 bool 值
    const dfs = (node) => {
        // 边界条件
        if (!node) {
            return true;
        }

        // 怎么直接结束递归？
        if (node.val !== val) {
            return false;
        }

        // dfs(node.left);
        // dfs(node.right);

        // 缺少的 return
        return dfs(node.left) && dfs(node.right);
    }

    return dfs(root);
};
```








965. 翻转等价二叉树 https://leetcode.cn/problems/flip-equivalent-binary-trees/
966. 翻转二叉树 https://leetcode.cn/problems/invert-binary-tree/
967. 合并二叉树 https://leetcode.cn/problems/merge-two-binary-trees/
968. 计算布尔二叉树的值 https://leetcode.cn/problems/evaluate-boolean-binary-tree/
969. 出现次数最多的子树元素和 https://leetcode.cn/problems/most-frequent-subtree-sum/
970. 节点与其祖先之间的最大差值 https://leetcode.cn/problems/maximum-difference-between-node-and-ancestor/
971. 二叉树中的最长交错路径 https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/
972. 根到叶路径上的不足节点 https://leetcode.cn/problems/insufficient-nodes-in-root-to-leaf-paths/

